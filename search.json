[{"title":"Educational Codeforces Round 169 (Rated for Div. 2) F. Make a Palindrome","path":"/2024/10/10/CF2004F/","content":"原题链接 tags: 思维，前缀和，*2600 题意给你一个长度为 序列 ，求 。 其中 将返回将数组 变为回文数组的最小操作次数，有以下两种操作： 选择数组中两个相邻的数 ，删除它们并用元素 插入。 选择数组中一个数 ，用两个正整数 替换它。 题解谁能想到一道 *2600 的题核心代码只有20行…… 显然存在一个上界 ，因为可以一直选两个数合并直到剩下一个数。 要得到这个上界还有一种方法是，每次选择两头中较大的那个数进行拆分成较小的数和另外一个数，这样做每次能使得两头变成一样，然后子问题的规模就减少了两个数字，同时多出来一个数，总体上相当于少了一个数，也是需要最多 次就能变成回文。 考虑如何减小操作次数。显然，如果两端的数已经相等，肯定不用操作。 但是有可能会出现这种情况 ，按照上面的处理办法最多 4 次，但是会发现前缀 和后缀 的和相等，于是可以用两次操作变成 ，总的操作次数来到 2 次，接下来考虑这样做为什么会减少操作次数。 设前缀的长度为 ，区间和相同的后缀长度为 ，按照我们原来的操作，在这两段数组上所需要的操作次数就是 ，但现在我们只需要将两段数组分别合并成一个数就能归约为相同的子问题，需要的操作次数为 。也就是说，只要有 的区间和相等，则对于 来说，答案就可以减少 1。 考虑贡献法，用桶来记录所有出现的区间和，对于每一个新加入的区间，若区间和为 ，则对答案的贡献为桶中记录的 的个数，因为其中任意一个与它组合都代表着一个区间的答案能够减 1。 有一种情况值得一提，假如是两个有着相同区间和的区间有重叠怎么办。 例如 和 ，其中 ，显然此时能够得到 和 的区间和也相等。因此 上的答案会被减少两次。 事实也是如此，我们可以选择 和 分别合并成一个数，然后在将剩余的 中的数合并成一个数，这样做相对于 ​ 的答案来说的确减少了 2 次操作。 时间复杂度： 。 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ int n; cin &gt;&gt; n; vector&lt;int&gt; a(n + 1), sum(n + 1); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + a[i]; int ans = 0; for (int l = 1; l &lt;= n; l++) { for (int r = l; r &lt;= n; r++) { ans += r - l; } } unordered_map&lt;int, int&gt; mp; for (int len = 1; len &lt;= n; len++) { for (int l = 1; l + len - 1 &lt;= n; l++) { int r = l + len - 1; int t = sum[r] - sum[l - 1]; ans -= mp[t]; mp[t]++; } } cout &lt;&lt; ans &lt;&lt; endl;}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;}"},{"title":"Pinely Round 4 (Div. 1 + Div. 2) F. Triangle Formation","path":"/2024/10/09/CF1991F/","content":"原题链接 tags: 思维，数学，*2200 题意给你一个长度为 的序列 ，进行 次询问，每次询问给出 ，询问区间 中能否选出 个数组成两个非退化的三角形。 非退化三角形：边长分别为 ，则有： 题解一开始以为会是一道数据结构大题…… 但是很容易发现，如果一个区间中不包含两个退化的三角形，则一定有任意三个数都不满足上面三个条件，更具体的，任意选三个数，最小的两个数相加一定小于等于最大的那个数。 那么将区间中所有的数按照递增排序，则有 ，这使我们联系到斐波那契数列，由于斐波那契数列增长速度相当快，打表发现满足小于 ​ 的只有前 44 项。 123456vector&lt;long long&gt; a = {1, 1};while (a.back() &lt;= 1e9) { a.push_back(a[a.size() - 1] + a[a.size() - 2]);}cout &lt;&lt; a.size() &lt;&lt; endl; // 45cout &lt;&lt; a.back() &lt;&lt; endl; // 1134903170 因此当区间长度大于 44 是就一定存在一个非退化的三角形，如果再往区间中扔 3 个数，则一定存在两个非退化的三角形，因此只要区间长度大于47，则一定存在两个非退化的三角形，下面考虑计算长度小于等于 47 的区间。 首先还是先将区间中所有数拿出来排序（因为现在个数很少，直接暴力验证）。有两个性质需要说明： 对于已经能够形成三角形的 3 个数，在保证仍然是最小的条件下将最小的边拉长将不会影响合法性。 对于已经能够形成三角形的 3 个数，在保证仍然是最大的条件下将最大的边拉短将不会影响合法性。 有了这两条性质，我们能够得到，在排好序的序列中，选择相邻的三个合法的一定更优，若不存在三个相邻的数能够组成非退化三角形则整个序列中都不会存在。 因此，我们只需要扫一遍排好序的序列，判断是否有不相交的两组相邻三个数能够组成非退化三角形，如果存在打印“YES”。 上面只考虑了两组数不相交的情况，但是有可能存在两组数相交的特例。例如： ，如果选择两组相邻的，即 和 ，前面第一组就不合法，如果按照 和 ​ 进行划分就存在合法解。因此我们还需要扫一遍相邻 6 个数判断是否存在两组合法解。 时间复杂度： 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int d[9][6] = { {1, 2, 4, 3, 5, 6}, {1, 2, 5, 3, 4, 6}, {1, 2, 6, 3, 4, 5}, {1, 3, 4, 2, 5, 6}, {1, 3, 5, 2, 4, 6}, {1, 3, 6, 2, 4, 5}, {1, 4, 5, 2, 3, 6}, {1, 4, 6, 2, 3, 5}, {1, 5, 6, 2, 3, 4}};int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int n, q; cin &gt;&gt; n &gt;&gt; q; vector&lt;int&gt; a(n + 1); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; while (q--) { int l, r; cin &gt;&gt; l &gt;&gt; r; if (r - l + 1 &gt;= 48) { cout &lt;&lt; \"YES\" &lt;&lt; endl; continue; } vector&lt;int&gt; nums; for (int i = l; i &lt;= r; i++) { nums.push_back(a[i]); } sort(nums.begin(), nums.end()); auto check = [&amp;](int a, int b, int c) { return a &lt; (b + c) &amp;&amp; b &lt; (a + c) &amp;&amp; c &lt; (a + b); }; vector&lt;int&gt; ok; bool have = false; for (int i = 0; i &lt; nums.size() - 2; i++) { if (check(nums[i], nums[i + 1], nums[i + 2])) { ok.push_back(i); if (ok.back() &gt; ok[0] + 2) { have = true; break; } } } if (ok.empty()) { // 不存在合法三角形 cout &lt;&lt; \"NO\" &lt;&lt; endl; continue; } if (have) { // 存在不相交的两组数 cout &lt;&lt; \"YES\" &lt;&lt; endl; continue; } for (int i = 0; i &lt; nums.size() - 5; i++) { for (int j = 0; j &lt; 9; j++) { if (check(nums[i + d[j][0] - 1], nums[i + d[j][1] - 1], nums[i + d[j][2] - 1]) &amp;&amp; check(nums[i + d[j][3] - 1], nums[i + d[j][4] - 1], nums[i + d[j][5] - 1])) { have = true; break; } } if (have) break; } if (have) { cout &lt;&lt; \"YES\" &lt;&lt; endl; } else { cout &lt;&lt; \"NO\" &lt;&lt; endl; } } return 0;}"},{"title":"Codeforces Round 959 sponsored by NEAR (Div. 1 + Div. 2) F. Stardew Valley","path":"/2024/10/08/CF1994F/","content":"原题连接 tag: 图论，欧拉回路，*2500 题意给出一个连通无向图， 个点 条边，边分成必选边和非必选边，可以存在重边和自环，要求选出一条路径包含所有的必选边，并且选出的路径上所有边（必选边和非必选边）只经过一次，并且能够回到起点。 题解由于路径上每条边只经过一次，并且要形成一个环，不难想到最后如果答案存在一定构成一条欧拉回路。回想欧拉回路的性质，每个点的度数都是偶数，且连通，因此题目的意思是：是否可以删掉原图中一些非必选边，使得剩下的图包含一个欧拉回路，也就是所有点的度数都是偶数。 有了这个想法后，发现代码并没有很容易实现。如果一开始用所有的边建图，然后考虑删掉一些边使得所有点的度数均为偶数，这样的做法很难找到删掉哪些边能够满足条件。 考虑反过来，如果我们从必选边开始，逐渐加入非必选边，那么最后的图一定是一个欧拉回路。因此我们可以从必选边开始，逐渐加入非必选边，如果最后的图是一个欧拉回路，那么就符合题意。 一个比较容易实现的方法是考虑非必选边所构成的子图，用 dfs 进行遍历，在 dfs 遍历的过程中，如果发现一个点的度数为奇数，则删掉和它父亲相连的一条边，使得这个点的度数变成偶数，最后如果根节点的度数是奇数，说明不能满足所有点的度数都是偶数的条件。 最后在所有选出的边中跑一边求欧拉回路即可。 时间复杂度 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; d(n + 1); vector&lt;vector&lt;int&gt;&gt; G(n + 1); vector&lt;int&gt; u(m + 1), v(m + 1), w(m + 1); for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i]; if (w[i]) d[u[i]]++, d[v[i]]++; G[u[i]].push_back(i), G[v[i]].push_back(i); } vector&lt;bool&gt; vis(n + 1); auto dfs = [&amp;](auto dfs, int x) -&gt; void { vis[x] = true; for (int i : G[x]) { int y = u[i] ^ v[i] ^ x; if (vis[y] || w[i] == 1) continue; dfs(dfs, y); if (d[y] &amp; 1) { d[x]--, d[y]--; w[i] = 1; // 选 } } }; for (int i = 1; i &lt;= n; i++) { if (!vis[i]) dfs(dfs, i); if (d[i] &amp; 1) { cout &lt;&lt; \"NO \"; return; } } cout &lt;&lt; \"YES \"; vector&lt;int&gt; ans; // 这种找欧拉回路T了 // auto dfs2 = [&amp;](auto dfs2, int x) -&gt; void { // for (int i : G[x]) { // if (w[i] == 0) continue; // int y = u[i] ^ v[i] ^ x; // w[i] = 0; // dfs2(dfs2, y); // } // ans.push_back(x); // }; auto dfs2 = [&amp;](auto dfs2, int x) -&gt; void { while (G[x].size()) { int i = G[x].back(); G[x].pop_back(); if (w[i] == 0) continue; int y = u[i] ^ v[i] ^ x; w[i] = 0; dfs2(dfs2, y); } ans.push_back(x); }; dfs2(dfs2, 1); cout &lt;&lt; ans.size() - 1 &lt;&lt; endl; for (int i = 0; i &lt; ans.size(); i++) { cout &lt;&lt; ans[i] &lt;&lt; \" \"[i == ans.size() - 1]; }}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;}"}]