[{"title":"All-Ukrainian School Olympiad in Informatics A. Gift","path":"/2024/10/12/CF76A/","content":"原题链接 tag: 最小生成树，贪心，*2200 题意给定一个 个点， 条边的图，同时给定两个正整数 ，每条边有 两个权重，求图的一棵生成树 ，使得 ​ 最小，求出这个最小值。 题解考虑暴力的做法，由于是双变量最优化问题，考虑枚举某一个变量对另外一个变量进行优化。在本题中可以枚举最大的 值，用所有小于 的边建图，然后在这张图上以最小化 跑 最小生成树。这样做的时间复杂度为 。 考虑如何优化，可以发现以下性质： 如果一个边在上一次枚举 的时候没有被选中，那么在后续的枚举（假设是从小到大枚举 值）中一定不会被选中。 因为前面已经可以选择一些拥有更小 的边来连接使相同的一些点连通，而且可选的边会越来越多，肯定没有必要选当前的边，直接删掉即可，这样可以保证每一轮所剩下的边只有最多 条。时间复杂度降为 ，大约 。 如果要继续优化，由于每次枚举 值时相对于上一轮只会多加入一条边，不用每次都重新排序然后跑 ，只需要在上一次得到的边集中按照插入排序的方式插入这条边，然后再跑 ，并将这一轮得到的边集传递给下一轮。 时间复杂度 。 代码In queue中…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define endl ' '#define ll long long#define PII pair&lt;int, int&gt;#define pi acos(-1.0)constexpr ll inf = 0x7fffffffffffffffll;struct edge { int u, v; ll g, s; bool operator==(const edge&amp; a) const { return u == a.u &amp;&amp; v == a.v &amp;&amp; g == a.g &amp;&amp; s == a.s; } bool operator&lt;(const edge&amp; a) const { return s &lt; a.s; }};struct DSU { std::vector&lt;int&gt; p; DSU(int n) { p.resize(n + 1); std::iota(p.begin(), p.end(), 0); } int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } bool same(int a, int b) { return find(a) == find(b); } void merge(int a, int b) { p[find(a)] = find(b); }};int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int n, m; ll G, S; cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; G &gt;&gt; S; vector&lt;edge&gt; e; for (int i = 1; i &lt;= m; i++) { int u, v; ll g, s; cin &gt;&gt; u &gt;&gt; v &gt;&gt; g &gt;&gt; s; if (u == v) continue; e.push_back({u, v, g, s}); } sort(e.begin(), e.end(), [](const edge&amp; a, const edge&amp; b) { return a.g &lt; b.g; }); vector&lt;edge&gt; cur; vector&lt;edge&gt; past; ll ans = inf; for (int i = 0; i &lt; e.size(); i++) { cur.assign(past.begin(), past.end()); cur.push_back(e[i]); for (int j = cur.size() - 1; j &gt;= 1; j--) { if (cur[j].s &lt; cur[j - 1].s) swap(cur[j], cur[j - 1]); } past.clear(); int cnt = 0; DSU T(n); ll max_g = 0, max_s = 0; for (int j = 0; j &lt; cur.size(); j++) { auto [u, v, g, s] = cur[j]; if (!T.same(u, v)) { T.merge(u, v); past.push_back(cur[j]); max_g = max(max_g, g), max_s = max(max_s, s); cnt++; if (cnt == n - 1) break; } } if (cnt == n - 1) ans = min(ans, G * max_g + S * max_s); } ans = ans == inf ? -1 : ans; cout &lt;&lt; ans &lt;&lt; endl; return 0;}"},{"title":"Codeforces Round 976 (Div. 2) and Divide By Zero 9.0","path":"/2024/10/11/CF2020/","content":"链接 VP赛时 ABCD，补题EF 分数：800 - 1200 - 1400 - 1800 - 2000 - 2900 A、B、C没什么好说的。 D题赛时卡了，没想到 这个条件怎么用，技巧 +1 E题回顾了一下一个较为经典的概率dp。 F题正好复习一下前段时间刚学会的 min_25 筛（确实好用，也顺便整理了一下 min_25 的板子。 A. Find Minimum Operations题意给定两个整数 ，每次操作可以从 上减去 的非负整数幂，求将 变成 的最小操作次数。 题解如果 ，显然需要 次。 否则预处理出所有小于 的 的幂，每次在二分找最大的不超过当前 的幂减去。如果最后 ，直接将答案加上剩下的 即可。 时间复杂度： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define endl ' '#define ll long longvoid solve(){ ll n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;ll&gt; a; ll t = k; a.push_back(1); if (k != 1) { while (t &lt;= n) { a.push_back(t); t *= k; } } int cnt = 0; while (n) { int l = 0, r = a.size() - 1; while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if (a[mid] &lt;= n) l = mid; else r = mid - 1; } n -= a[l]; cnt++; if (a[l] == 1) { cnt += n; break; } } cout &lt;&lt; cnt &lt;&lt; endl;}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;} B. Brightness Begins题意有 个灯泡，编号为 ，最开始所有灯都是亮的，然后进行如下操作： 对于 ，反转所有 灯泡。 执行完所有操作后，将会有一些灯泡是亮的。 找出最小的 使得执行完操作后恰好有 ​ 个灯泡是亮的。 题解每个灯泡只会被自己的因数操作翻转，如果一个数的因数是偶数，则操作完后仍然是亮的。因数为奇数当且仅当这个数是完全平方数。 因为原题可以变成找出最小的 使得 中恰好有 个完全平方数。 时间复杂度： 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;#define endl ' '#define ll long longvoid solve(){ ll k; cin &gt;&gt; k; auto check = [&amp;](ll x) { ll l = 1, r = 2e9; while (l &lt; r) { ll mid = (l + r + 1) &gt;&gt; 1; if (mid * mid &lt;= x) l = mid; else r = mid - 1; } return l &lt;= x - k; }; ll l = 1, r = 4e18; while (l &lt; r) { ll mid = (l + r) &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; } cout &lt;&lt; l &lt;&lt; endl;}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;} C. Bitwise Balancing题意给定三个非负整数 ，求方程Misplaced & (a| b)-(a&amp;c)=d 的解，无解打印 -1。 题解考虑拆位，如果 上某一位是1，则 上这一位必为1，Misplaced &a&amp;c 上这一位必为 0，因为不可能出现 上这一位为0，Misplaced &a&amp;c 上这一位为 1的情况。 如果 上某一位是0，则两者在这一位上必然相等。 分情况讨论即可。 时间复杂度： 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;#define endl ' '#define ll long longvoid solve(){ ll b, c, d; cin &gt;&gt; b &gt;&gt; c &gt;&gt; d; ll ans = 0; for (int i = 0; i &lt;= 62; i++) { if ((d &gt;&gt; i) &amp; 1) { if (!((b &gt;&gt; i) &amp; 1)) { if ((c &gt;&gt; i) &amp; 1) { cout &lt;&lt; -1 &lt;&lt; endl; return; } else ans += (1ll &lt;&lt; i); } } else { if ((b &gt;&gt; i) &amp; 1) { if (!((c &gt;&gt; i) &amp; 1)) { cout &lt;&lt; -1 &lt;&lt; endl; return; } else { ans += (1ll &lt;&lt; i); } } } } // assert((ans | b) - (ans &amp; c) == d); cout &lt;&lt; ans &lt;&lt; endl;}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;} D. Connect the Dots题意有 这些点，起初都是孤立点，接下来 次操作，每次操作选择三个整数 ，然后连接 这些点，使其连通。 执行完所有操作后，问这些点形成了多少个连通块。 题解发现 很小，最大只有10，考虑维护每个点后面十个点是否与它连通，连通可以直接用并查集维护。 由于每次操作涉及多个点，为了降低时间复杂度，每次将从 开始打标记，当计算完 和他后面十个点的边之后，将 的标记传递给 ，直到序列的结尾点。 时间复杂度： 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;struct DSU { std::vector&lt;int&gt; p; DSU(int n) { p.resize(n + 1); std::iota(p.begin(), p.end(), 0); } int find(int x) { if (p[x] != x) { p[x] = find(p[x]); } return p[x]; } bool same(int a, int b) { return find(a) == find(b); } void merge(int a, int b) { p[find(a)] = find(b); }};void solve(){ int n, m; cin &gt;&gt; n &gt;&gt; m; DSU T(n); int a, d, k; vector&lt;vector&lt;int&gt;&gt; tag(n + 1, vector&lt;int&gt;(11)); for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; a &gt;&gt; d &gt;&gt; k; tag[a][d]++; tag[a + k * d][d]--; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= 10; j++) { if (tag[i][j] &gt; 0) { T.merge(i, i + j); tag[i + j][j] += tag[i][j]; } } } int ans = 0; unordered_set&lt;int&gt; st; for (int i = 1; i &lt;= n; i++) st.insert(T.find(i)); cout &lt;&lt; st.size() &lt;&lt; endl;}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;} E. Expected Power题意给定一个数组 和概率数组 ，每个 有 的概率被插入到可重集 中。 求 。 其中 表示 中所有元素的异或和。 题解观察到 范围很小，于是 的范围也一定是 ，于是 可以表示为而 可以用经典的概率 dp 求解： 设 为考虑前 个数，选择一些数使得异或和为 的概率，于是有转移方程：直接计算即可，注意到 只会从 转移而来，可以滚动掉一维。 时间复杂度： 。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;#define endl ' '#define ll long longconstexpr ll mod = 1e9 + 7;constexpr ll mu = 285700002;void solve(){ int n; cin &gt;&gt; n; vector&lt;ll&gt; a(n + 1), p(n + 1); ll B = 0; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; B = max(B, __lg(a[i])); } B++; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i], p[i] = (p[i] * mu) % mod; vector&lt;ll&gt; dp(1024); dp[0] = 1; for (int i = 1; i &lt;= n; i++) { vector&lt;ll&gt; nxt(1024); for (int j = 0; j &lt; 1024; j++) { nxt[j] = (nxt[j] + (dp[j] * (1 - p[i] + mod) % mod) % mod) % mod; nxt[j ^ a[i]] = (nxt[j ^ a[i]] + dp[j] * p[i] % mod) % mod; } for (int j = 0; j &lt; 1024; j++) dp[j] = nxt[j]; } ll ans = 0; for (int i = 1; i &lt; (1 &lt;&lt; B); i++) { ans = (ans + ((1ll * i * i) % mod) * dp[i] % mod) % mod; } cout &lt;&lt; ans &lt;&lt; endl;}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;} F. Count Leavestag ：min_25筛 题意原题题意可化为： 求 。 其中 ，的因数个数 。 题解首先不难发现当给定 时，如果 则 ，也就是说 满足积性函数。 考虑 中 为质数时， 的值相当于求有多少条长度为 的路径使得 中始终有 ， 为素数时，这样的路径只会有 条。 考虑 其中 为素数，则这样的路径有 种，而 是多项式形式，因此有 ​ ，考虑用 min_25 筛求前缀和。 时间复杂度： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;#define endl ' '#define ll long longconstexpr ll mod = 1e9 + 7;constexpr int N = 1e6 + 10;ll qpow(ll aa, int bb){ ll res = 1; while (bb) { if (bb &amp; 1) res = (res * aa) % mod; aa = (aa * aa) % mod; bb &gt;&gt;= 1; } return res;}struct Combnum { vector&lt;ll&gt; fac, ifac; int n; void init(int _n) { this-&gt;n = _n; fac.resize(n + 1, 0), ifac.resize(n + 1, 0); fac[0] = 1; for (int i = 1; i &lt;= n; i++) fac[i] = fac[i - 1] * i % mod; ifac[n] = qpow(fac[n], mod - 2); for (int i = n - 1; i &gt;= 0; i--) { ifac[i] = ifac[i + 1] * (i + 1) % mod; } } ll C(ll i, ll j) { if (i &lt; j) return 0; return (fac[i] * ifac[j] % mod) * ifac[i - j] % mod; }} c;void solve(){ ll n, K, d, cp, cnt = 0, tot = 0; cin &gt;&gt; n &gt;&gt; K &gt;&gt; d; vector&lt;ll&gt; primes, sum, w, id1, id2, g; vector&lt;bool&gt; st; cp = c.C(K + d, d); ll sq = sqrt(n); primes.assign(2 * sq + 7, 0); st.assign(2 * sq + 7, false); g.assign(2 * sq + 7, 0); w.assign(2 * sq + 7, 0); id1.assign(2 * sq + 7, 0); id2.assign(2 * sq + 7, 0); sum.assign(2 * sq + 7, 0); auto sieve = [&amp;](int n) -&gt; void { for (int i = 2; i &lt;= n; i++) { if (!st[i]) primes[++cnt] = i, sum[cnt] = (sum[cnt - 1] + cp) % mod; for (int j = 1; j &lt;= cnt &amp;&amp; i * primes[j] &lt;= n; j++) { st[i * primes[j]] = true; if (i % primes[j] == 0) break; } } }; sieve(sq); for (ll l = 1, r; l &lt;= n; l = r + 1) { r = min(n, n / (n / l)); w[++tot] = n / l; g[tot] = cp * (w[tot] % mod - 1) % mod; if (w[tot] &lt;= sq) id1[w[tot]] = tot; else id2[n / w[tot]] = tot; } for (int j = 1; j &lt;= cnt; j++) { for (int i = 1; i &lt;= tot &amp;&amp; primes[j] * primes[j] &lt;= w[i]; i++) { ll tmp = w[i] / primes[j]; int p = tmp &lt;= sq ? id1[tmp] : id2[n / tmp]; g[i] = (g[i] - (g[p] - sum[j - 1] + mod) % mod + mod) % mod; } } auto S = [&amp;](auto S, ll i, ll j) -&gt; ll { if (primes[j] &gt;= i) return 0; ll p = i &lt;= sq ? id1[i] : id2[n / i]; ll ans = (g[p] - sum[j] + mod) % mod; for (int k = j + 1; k &lt;= cnt &amp;&amp; primes[k] * primes[k] &lt;= i; k++) { ll pe = primes[k]; for (int e = 1; pe &lt;= i; e++, pe = pe * primes[k]) { ans = (ans + c.C(d + e * K, d) * ((S(S, i / pe, k) + (e &gt; 1)) % mod) % mod) % mod; } } return ans; }; cout &lt;&lt; (S(S, n, 0) + 1) % mod &lt;&lt; endl;}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; c.init(N * 10); while (tt--) { solve(); } return 0;}"},{"title":"Educational Codeforces Round 169 (Rated for Div. 2) F. Make a Palindrome","path":"/2024/10/10/CF2004F/","content":"原题链接 tags: 思维，前缀和，*2600 题意给你一个长度为 序列 ，求 。 其中 将返回将数组 变为回文数组的最小操作次数，有以下两种操作： 选择数组中两个相邻的数 ，删除它们并用元素 插入。 选择数组中一个数 ，用两个正整数 替换它。 题解谁能想到一道 *2600 的题核心代码只有20行…… 显然存在一个上界 ，因为可以一直选两个数合并直到剩下一个数。 要得到这个上界还有一种方法是，每次选择两头中较大的那个数进行拆分成较小的数和另外一个数，这样做每次能使得两头变成一样，然后子问题的规模就减少了两个数字，同时多出来一个数，总体上相当于少了一个数，也是需要最多 次就能变成回文。 考虑如何减小操作次数。显然，如果两端的数已经相等，肯定不用操作。 但是有可能会出现这种情况 ，按照上面的处理办法最多 4 次，但是会发现前缀 和后缀 的和相等，于是可以用两次操作变成 ，总的操作次数来到 2 次，接下来考虑这样做为什么会减少操作次数。 设前缀的长度为 ，区间和相同的后缀长度为 ，按照我们原来的操作，在这两段数组上所需要的操作次数就是 ，但现在我们只需要将两段数组分别合并成一个数就能归约为相同的子问题，需要的操作次数为 。也就是说，只要有 的区间和相等，则对于 来说，答案就可以减少 1。 考虑贡献法，用桶来记录所有出现的区间和，对于每一个新加入的区间，若区间和为 ，则对答案的贡献为桶中记录的 的个数，因为其中任意一个与它组合都代表着一个区间的答案能够减 1。 有一种情况值得一提，假如是两个有着相同区间和的区间有重叠怎么办。 例如 和 ，其中 ，显然此时能够得到 和 的区间和也相等。因此 上的答案会被减少两次。 事实也是如此，我们可以选择 和 分别合并成一个数，然后在将剩余的 中的数合并成一个数，这样做相对于 ​ 的答案来说的确减少了 2 次操作。 时间复杂度： 。 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ int n; cin &gt;&gt; n; vector&lt;int&gt; a(n + 1), sum(n + 1); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + a[i]; int ans = 0; for (int l = 1; l &lt;= n; l++) { for (int r = l; r &lt;= n; r++) { ans += r - l; } } unordered_map&lt;int, int&gt; mp; for (int len = 1; len &lt;= n; len++) { for (int l = 1; l + len - 1 &lt;= n; l++) { int r = l + len - 1; int t = sum[r] - sum[l - 1]; ans -= mp[t]; mp[t]++; } } cout &lt;&lt; ans &lt;&lt; endl;}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;}"},{"title":"Pinely Round 4 (Div. 1 + Div. 2) F. Triangle Formation","path":"/2024/10/09/CF1991F/","content":"原题链接 tags: 思维，数学，*2200 题意给你一个长度为 的序列 ，进行 次询问，每次询问给出 ，询问区间 中能否选出 个数组成两个非退化的三角形。 非退化三角形：边长分别为 ，则有： 题解一开始以为会是一道数据结构大题…… 但是很容易发现，如果一个区间中不包含两个退化的三角形，则一定有任意三个数都不满足上面三个条件，更具体的，任意选三个数，最小的两个数相加一定小于等于最大的那个数。 那么将区间中所有的数按照递增排序，则有 ，这使我们联系到斐波那契数列，由于斐波那契数列增长速度相当快，打表发现满足小于 ​ 的只有前 44 项。 123456vector&lt;long long&gt; a = {1, 1};while (a.back() &lt;= 1e9) { a.push_back(a[a.size() - 1] + a[a.size() - 2]);}cout &lt;&lt; a.size() &lt;&lt; endl; // 45cout &lt;&lt; a.back() &lt;&lt; endl; // 1134903170 因此当区间长度大于 44 是就一定存在一个非退化的三角形，如果再往区间中扔 3 个数，则一定存在两个非退化的三角形，因此只要区间长度大于47，则一定存在两个非退化的三角形，下面考虑计算长度小于等于 47 的区间。 首先还是先将区间中所有数拿出来排序（因为现在个数很少，直接暴力验证）。有两个性质需要说明： 对于已经能够形成三角形的 3 个数，在保证仍然是最小的条件下将最小的边拉长将不会影响合法性。 对于已经能够形成三角形的 3 个数，在保证仍然是最大的条件下将最大的边拉短将不会影响合法性。 有了这两条性质，我们能够得到，在排好序的序列中，选择相邻的三个合法的一定更优，若不存在三个相邻的数能够组成非退化三角形则整个序列中都不会存在。 因此，我们只需要扫一遍排好序的序列，判断是否有不相交的两组相邻三个数能够组成非退化三角形，如果存在打印“YES”。 上面只考虑了两组数不相交的情况，但是有可能存在两组数相交的特例。例如： ，如果选择两组相邻的，即 和 ，前面第一组就不合法，如果按照 和 ​ 进行划分就存在合法解。因此我们还需要扫一遍相邻 6 个数判断是否存在两组合法解。 时间复杂度： 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int d[9][6] = { {1, 2, 4, 3, 5, 6}, {1, 2, 5, 3, 4, 6}, {1, 2, 6, 3, 4, 5}, {1, 3, 4, 2, 5, 6}, {1, 3, 5, 2, 4, 6}, {1, 3, 6, 2, 4, 5}, {1, 4, 5, 2, 3, 6}, {1, 4, 6, 2, 3, 5}, {1, 5, 6, 2, 3, 4}};int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int n, q; cin &gt;&gt; n &gt;&gt; q; vector&lt;int&gt; a(n + 1); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; while (q--) { int l, r; cin &gt;&gt; l &gt;&gt; r; if (r - l + 1 &gt;= 48) { cout &lt;&lt; \"YES\" &lt;&lt; endl; continue; } vector&lt;int&gt; nums; for (int i = l; i &lt;= r; i++) { nums.push_back(a[i]); } sort(nums.begin(), nums.end()); auto check = [&amp;](int a, int b, int c) { return a &lt; (b + c) &amp;&amp; b &lt; (a + c) &amp;&amp; c &lt; (a + b); }; vector&lt;int&gt; ok; bool have = false; for (int i = 0; i &lt; nums.size() - 2; i++) { if (check(nums[i], nums[i + 1], nums[i + 2])) { ok.push_back(i); if (ok.back() &gt; ok[0] + 2) { have = true; break; } } } if (ok.empty()) { // 不存在合法三角形 cout &lt;&lt; \"NO\" &lt;&lt; endl; continue; } if (have) { // 存在不相交的两组数 cout &lt;&lt; \"YES\" &lt;&lt; endl; continue; } for (int i = 0; i &lt; nums.size() - 5; i++) { for (int j = 0; j &lt; 9; j++) { if (check(nums[i + d[j][0] - 1], nums[i + d[j][1] - 1], nums[i + d[j][2] - 1]) &amp;&amp; check(nums[i + d[j][3] - 1], nums[i + d[j][4] - 1], nums[i + d[j][5] - 1])) { have = true; break; } } if (have) break; } if (have) { cout &lt;&lt; \"YES\" &lt;&lt; endl; } else { cout &lt;&lt; \"NO\" &lt;&lt; endl; } } return 0;}"},{"title":"Codeforces Round 959 sponsored by NEAR (Div. 1 + Div. 2) F. Stardew Valley","path":"/2024/10/08/CF1994F/","content":"原题连接 tag: 图论，欧拉回路，*2500 题意给出一个连通无向图， 个点 条边，边分成必选边和非必选边，可以存在重边和自环，要求选出一条路径包含所有的必选边，并且选出的路径上所有边（必选边和非必选边）只经过一次，并且能够回到起点。 题解由于路径上每条边只经过一次，并且要形成一个环，不难想到最后如果答案存在一定构成一条欧拉回路。回想欧拉回路的性质，每个点的度数都是偶数，且连通，因此题目的意思是：是否可以删掉原图中一些非必选边，使得剩下的图包含一个欧拉回路，也就是所有点的度数都是偶数。 有了这个想法后，发现代码并没有很容易实现。如果一开始用所有的边建图，然后考虑删掉一些边使得所有点的度数均为偶数，这样的做法很难找到删掉哪些边能够满足条件。 考虑反过来，如果我们从必选边开始，逐渐加入非必选边，那么最后的图一定是一个欧拉回路。因此我们可以从必选边开始，逐渐加入非必选边，如果最后的图是一个欧拉回路，那么就符合题意。 一个比较容易实现的方法是考虑非必选边所构成的子图，用 dfs 进行遍历，在 dfs 遍历的过程中，如果发现一个点的度数为奇数，则删掉和它父亲相连的一条边，使得这个点的度数变成偶数，最后如果根节点的度数是奇数，说明不能满足所有点的度数都是偶数的条件。 最后在所有选出的边中跑一边求欧拉回路即可。 时间复杂度 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; d(n + 1); vector&lt;vector&lt;int&gt;&gt; G(n + 1); vector&lt;int&gt; u(m + 1), v(m + 1), w(m + 1); for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i]; if (w[i]) d[u[i]]++, d[v[i]]++; G[u[i]].push_back(i), G[v[i]].push_back(i); } vector&lt;bool&gt; vis(n + 1); auto dfs = [&amp;](auto dfs, int x) -&gt; void { vis[x] = true; for (int i : G[x]) { int y = u[i] ^ v[i] ^ x; if (vis[y] || w[i] == 1) continue; dfs(dfs, y); if (d[y] &amp; 1) { d[x]--, d[y]--; w[i] = 1; // 选 } } }; for (int i = 1; i &lt;= n; i++) { if (!vis[i]) dfs(dfs, i); if (d[i] &amp; 1) { cout &lt;&lt; \"NO \"; return; } } cout &lt;&lt; \"YES \"; vector&lt;int&gt; ans; // 这种找欧拉回路T了 // auto dfs2 = [&amp;](auto dfs2, int x) -&gt; void { // for (int i : G[x]) { // if (w[i] == 0) continue; // int y = u[i] ^ v[i] ^ x; // w[i] = 0; // dfs2(dfs2, y); // } // ans.push_back(x); // }; auto dfs2 = [&amp;](auto dfs2, int x) -&gt; void { while (G[x].size()) { int i = G[x].back(); G[x].pop_back(); if (w[i] == 0) continue; int y = u[i] ^ v[i] ^ x; w[i] = 0; dfs2(dfs2, y); } ans.push_back(x); }; dfs2(dfs2, 1); cout &lt;&lt; ans.size() - 1 &lt;&lt; endl; for (int i = 0; i &lt; ans.size(); i++) { cout &lt;&lt; ans[i] &lt;&lt; \" \"[i == ans.size() - 1]; }}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;}"}]