[{"title":"Codeforces Round 959 sponsored by NEAR (Div. 1 + Div. 2) F. Stardew Valley","path":"/2024/10/08/Codeforces Round 959 sponsored by NEAR (Div. 1 + Div. 2) F. Stardew Valley/","content":"原题连接 题意给出一个连通无向图， 个点 条边，边分成必选边和非必选边，可以存在重边和自环，要求选出一条路径包含所有的必选边，并且选出的路径上所有边（必选边和非必选边）只经过一次，并且能够回到起点。 题解由于路径上每条边只经过一次，并且要形成一个环，不难想到最后如果答案存在一定构成一条欧拉回路。回想欧拉回路的性质，每个点的度数都是偶数，且连通，因此题目的意思是：是否可以删掉原图中一些非必选边，使得剩下的图包含一个欧拉回路，也就是所有点的度数都是偶数。 有了这个想法后，发现代码并没有很容易实现。如果一开始用所有的边建图，然后考虑删掉一些边使得所有点的度数均为偶数，这样的做法很难找到删掉哪些边能够满足条件。 考虑反过来，如果我们从必选边开始，逐渐加入非必选边，那么最后的图一定是一个欧拉回路。因此我们可以从必选边开始，逐渐加入非必选边，如果最后的图是一个欧拉回路，那么就符合题意。 一个比较容易实现的方法是考虑非必选边所构成的子图，用 dfs 进行遍历，在 dfs 遍历的过程中，如果发现一个点的度数为奇数，则删掉和它父亲相连的一条边，使得这个点的度数变成偶数，最后如果根节点的度数是奇数，说明不能满足所有点的度数都是偶数的条件。 最后在所有选出的边中跑一边求欧拉回路即可。 时间复杂度 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; d(n + 1); vector&lt;vector&lt;int&gt;&gt; G(n + 1); vector&lt;int&gt; u(m + 1), v(m + 1), w(m + 1); for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i]; if (w[i]) d[u[i]]++, d[v[i]]++; G[u[i]].push_back(i), G[v[i]].push_back(i); } vector&lt;bool&gt; vis(n + 1); auto dfs = [&amp;](auto dfs, int x) -&gt; void { vis[x] = true; for (int i : G[x]) { int y = u[i] ^ v[i] ^ x; if (vis[y] || w[i] == 1) continue; dfs(dfs, y); if (d[y] &amp; 1) { d[x]--, d[y]--; w[i] = 1; // 选 } } }; for (int i = 1; i &lt;= n; i++) { if (!vis[i]) dfs(dfs, i); if (d[i] &amp; 1) { cout &lt;&lt; \"NO \"; return; } } cout &lt;&lt; \"YES \"; vector&lt;int&gt; ans; // 这种找欧拉回路T了 // auto dfs2 = [&amp;](auto dfs2, int x) -&gt; void { // for (int i : G[x]) { // if (w[i] == 0) continue; // int y = u[i] ^ v[i] ^ x; // w[i] = 0; // dfs2(dfs2, y); // } // ans.push_back(x); // }; auto dfs2 = [&amp;](auto dfs2, int x) -&gt; void { while (G[x].size()) { int i = G[x].back(); G[x].pop_back(); if (w[i] == 0) continue; int y = u[i] ^ v[i] ^ x; w[i] = 0; dfs2(dfs2, y); } ans.push_back(x); }; dfs2(dfs2, 1); cout &lt;&lt; ans.size() - 1 &lt;&lt; endl; for (int i = 0; i &lt; ans.size(); i++) { cout &lt;&lt; ans[i] &lt;&lt; \" \"[i == ans.size() - 1]; }}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;}"}]