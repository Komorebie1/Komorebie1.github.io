[{"title":"Pinely Round 4 (Div. 1 + Div. 2) F. Triangle Formation","path":"/2024/10/09/CF1991F/","content":"原题链接 tags: 思维，数学，*2200 题意给你一个长度为 的序列 ，进行 次询问，每次询问给出 ，询问区间 中能否选出 个数组成两个非退化的三角形。 非退化三角形：边长分别为 ，则有： 题解一开始以为会是一道数据结构大题…… 但是很容易发现，如果一个区间中不包含两个退化的三角形，则一定有任意三个数都不满足上面三个条件，更具体的，任意选三个数，最小的两个数相加一定小于等于最大的那个数。 那么将区间中所有的数按照递增排序，则有 ，这使我们联系到斐波那契数列，由于斐波那契数列增长速度相当快，打表发现满足小于 ​ 的只有前 44 项。 123456vector&lt;long long&gt; a = {1, 1};while (a.back() &lt;= 1e9) { a.push_back(a[a.size() - 1] + a[a.size() - 2]);}cout &lt;&lt; a.size() &lt;&lt; endl; // 45cout &lt;&lt; a.back() &lt;&lt; endl; // 1134903170 因此当区间长度大于 44 是就一定存在一个非退化的三角形，如果再往区间中扔 3 个数，则一定存在两个非退化的三角形，因此只要区间长度大于47，则一定存在两个非退化的三角形，下面考虑计算长度小于等于 47 的区间。 首先还是先将区间中所有数拿出来排序（因为现在个数很少，直接暴力验证）。有两个性质需要说明： 对于已经能够形成三角形的 3 个数，在保证仍然是最小的条件下将最小的边拉长将不会影响合法性。 对于已经能够形成三角形的 3 个数，在保证仍然是最大的条件下将最大的边拉短将不会影响合法性。 有了这两条性质，我们能够得到，在排好序的序列中，选择相邻的三个合法的一定更优，若不存在三个相邻的数能够组成非退化三角形则整个序列中都不会存在。 因此，我们只需要扫一遍排好序的序列，判断是否有不相交的两组相邻三个数能够组成非退化三角形，如果存在打印“YES”。 上面只考虑了两组数不相交的情况，但是有可能存在两组数相交的特例。例如： ，如果选择两组相邻的，即 和 ，前面第一组就不合法，如果按照 和 ​ 进行划分就存在合法解。因此我们还需要扫一遍相邻 6 个数判断是否存在两组合法解。 时间复杂度： 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int d[9][6] = { {1, 2, 4, 3, 5, 6}, {1, 2, 5, 3, 4, 6}, {1, 2, 6, 3, 4, 5}, {1, 3, 4, 2, 5, 6}, {1, 3, 5, 2, 4, 6}, {1, 3, 6, 2, 4, 5}, {1, 4, 5, 2, 3, 6}, {1, 4, 6, 2, 3, 5}, {1, 5, 6, 2, 3, 4}};int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int n, q; cin &gt;&gt; n &gt;&gt; q; vector&lt;int&gt; a(n + 1); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; while (q--) { int l, r; cin &gt;&gt; l &gt;&gt; r; if (r - l + 1 &gt;= 48) { cout &lt;&lt; \"YES\" &lt;&lt; endl; continue; } vector&lt;int&gt; nums; for (int i = l; i &lt;= r; i++) { nums.push_back(a[i]); } sort(nums.begin(), nums.end()); auto check = [&amp;](int a, int b, int c) { return a &lt; (b + c) &amp;&amp; b &lt; (a + c) &amp;&amp; c &lt; (a + b); }; vector&lt;int&gt; ok; bool have = false; for (int i = 0; i &lt; nums.size() - 2; i++) { if (check(nums[i], nums[i + 1], nums[i + 2])) { ok.push_back(i); if (ok.back() &gt; ok[0] + 2) { have = true; break; } } } if (ok.empty()) { // 不存在合法三角形 cout &lt;&lt; \"NO\" &lt;&lt; endl; continue; } if (have) { // 存在不相交的两组数 cout &lt;&lt; \"YES\" &lt;&lt; endl; continue; } for (int i = 0; i &lt; nums.size() - 5; i++) { for (int j = 0; j &lt; 9; j++) { if (check(nums[i + d[j][0] - 1], nums[i + d[j][1] - 1], nums[i + d[j][2] - 1]) &amp;&amp; check(nums[i + d[j][3] - 1], nums[i + d[j][4] - 1], nums[i + d[j][5] - 1])) { have = true; break; } } if (have) break; } if (have) { cout &lt;&lt; \"YES\" &lt;&lt; endl; } else { cout &lt;&lt; \"NO\" &lt;&lt; endl; } } return 0;}"},{"title":"Codeforces Round 959 sponsored by NEAR (Div. 1 + Div. 2) F. Stardew Valley","path":"/2024/10/08/CF1994F/","content":"原题连接 tag: 图论，欧拉回路，*2500 题意给出一个连通无向图， 个点 条边，边分成必选边和非必选边，可以存在重边和自环，要求选出一条路径包含所有的必选边，并且选出的路径上所有边（必选边和非必选边）只经过一次，并且能够回到起点。 题解由于路径上每条边只经过一次，并且要形成一个环，不难想到最后如果答案存在一定构成一条欧拉回路。回想欧拉回路的性质，每个点的度数都是偶数，且连通，因此题目的意思是：是否可以删掉原图中一些非必选边，使得剩下的图包含一个欧拉回路，也就是所有点的度数都是偶数。 有了这个想法后，发现代码并没有很容易实现。如果一开始用所有的边建图，然后考虑删掉一些边使得所有点的度数均为偶数，这样的做法很难找到删掉哪些边能够满足条件。 考虑反过来，如果我们从必选边开始，逐渐加入非必选边，那么最后的图一定是一个欧拉回路。因此我们可以从必选边开始，逐渐加入非必选边，如果最后的图是一个欧拉回路，那么就符合题意。 一个比较容易实现的方法是考虑非必选边所构成的子图，用 dfs 进行遍历，在 dfs 遍历的过程中，如果发现一个点的度数为奇数，则删掉和它父亲相连的一条边，使得这个点的度数变成偶数，最后如果根节点的度数是奇数，说明不能满足所有点的度数都是偶数的条件。 最后在所有选出的边中跑一边求欧拉回路即可。 时间复杂度 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;void solve(){ int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; d(n + 1); vector&lt;vector&lt;int&gt;&gt; G(n + 1); vector&lt;int&gt; u(m + 1), v(m + 1), w(m + 1); for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i]; if (w[i]) d[u[i]]++, d[v[i]]++; G[u[i]].push_back(i), G[v[i]].push_back(i); } vector&lt;bool&gt; vis(n + 1); auto dfs = [&amp;](auto dfs, int x) -&gt; void { vis[x] = true; for (int i : G[x]) { int y = u[i] ^ v[i] ^ x; if (vis[y] || w[i] == 1) continue; dfs(dfs, y); if (d[y] &amp; 1) { d[x]--, d[y]--; w[i] = 1; // 选 } } }; for (int i = 1; i &lt;= n; i++) { if (!vis[i]) dfs(dfs, i); if (d[i] &amp; 1) { cout &lt;&lt; \"NO \"; return; } } cout &lt;&lt; \"YES \"; vector&lt;int&gt; ans; // 这种找欧拉回路T了 // auto dfs2 = [&amp;](auto dfs2, int x) -&gt; void { // for (int i : G[x]) { // if (w[i] == 0) continue; // int y = u[i] ^ v[i] ^ x; // w[i] = 0; // dfs2(dfs2, y); // } // ans.push_back(x); // }; auto dfs2 = [&amp;](auto dfs2, int x) -&gt; void { while (G[x].size()) { int i = G[x].back(); G[x].pop_back(); if (w[i] == 0) continue; int y = u[i] ^ v[i] ^ x; w[i] = 0; dfs2(dfs2, y); } ans.push_back(x); }; dfs2(dfs2, 1); cout &lt;&lt; ans.size() - 1 &lt;&lt; endl; for (int i = 0; i &lt; ans.size(); i++) { cout &lt;&lt; ans[i] &lt;&lt; \" \"[i == ans.size() - 1]; }}int main(){ ios::sync_with_stdio(false), cin.tie(nullptr); int tt; cin &gt;&gt; tt; while (tt--) { solve(); } return 0;}"}]